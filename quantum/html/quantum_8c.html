<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quantum Computer Outreach Project: dspic33e/qcomp-sim-c.X/quantum.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quantum Computer Outreach Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_15ff54b15d1e25f7ce738c9a3fe98b31.html">dspic33e</a></li><li class="navelem"><a class="el" href="dir_41732047a0354d31db2b57d6efa10cab.html">qcomp-sim-c.X</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">quantum.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Description: Contains matrix and vector arithmetic for simulating one qubit.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="io_8h_source.html">io.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="quantum_8h_source.html">quantum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="time_8h_source.html">time.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for quantum.c:</div>
<div class="dyncontent">
<div class="center"><img src="quantum_8c__incl.png" border="0" usemap="#dspic33e_2qcomp-sim-c_8X_2quantum_8c" alt=""/></div>
<map name="dspic33e_2qcomp-sim-c_8X_2quantum_8c" id="dspic33e_2qcomp-sim-c_8X_2quantum_8c">
<area shape="rect" id="node2" href="io_8h.html" title="Description: Header file for input output functions. " alt="" coords="279,95,322,121"/>
<area shape="rect" id="node6" href="quantum_8h.html" title="Description: Header file containing all the matrix arithmetic for simulating a single qubit..." alt="" coords="90,95,173,121"/>
<area shape="rect" id="node8" href="time_8h.html" title="Description: Header file containing all the timing functions. " alt="" coords="197,95,255,121"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a43ed06e2eeade77b541d88b3fe875a05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a43ed06e2eeade77b541d88b3fe875a05">NUM_MAX_AMPS</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a43ed06e2eeade77b541d88b3fe875a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ca7e4d2cbc30261d3d6e1971cf03632"><td class="memItemLeft" align="right" valign="top"><a id="a9ca7e4d2cbc30261d3d6e1971cf03632"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cadd</b> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> a, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> b, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> result)</td></tr>
<tr class="separator:a9ca7e4d2cbc30261d3d6e1971cf03632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff0520252fc4c9d171f146df34133ff"><td class="memItemLeft" align="right" valign="top"><a id="a2ff0520252fc4c9d171f146df34133ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmul</b> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> a, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> b, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> result)</td></tr>
<tr class="separator:a2ff0520252fc4c9d171f146df34133ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c505ea21f44c1e8e4f15b71b19b8cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="quantum_8h.html#a66dbef8ee970f4d9747e8bb5533d2a92">Q15</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a4c505ea21f44c1e8e4f15b71b19b8cf3">absolute</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> x)</td></tr>
<tr class="separator:a4c505ea21f44c1e8e4f15b71b19b8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7978688debb14063b164d6f6b279d839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a7978688debb14063b164d6f6b279d839">make_ops</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> X[2][2], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> Y[2][2], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> Z[2][2], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> H[2][2])</td></tr>
<tr class="memdesc:a7978688debb14063b164d6f6b279d839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create complex X, Y, Z and H.  <a href="#a7978688debb14063b164d6f6b279d839">More...</a><br /></td></tr>
<tr class="separator:a7978688debb14063b164d6f6b279d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51694e4352698790c3ae8337e72a439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#aa51694e4352698790c3ae8337e72a439">make_ops_4</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> CNOT[4][4], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> CPHASE[4][4], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> SWAP[4][4])</td></tr>
<tr class="separator:aa51694e4352698790c3ae8337e72a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddf4816d6adf12474058fd944b210d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a2ddf4816d6adf12474058fd944b210d2">zero_state</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int Qnum)</td></tr>
<tr class="memdesc:a2ddf4816d6adf12474058fd944b210d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise state to the vacuum (zero apart from the first position) Specify the dimension &ndash; of the matrix, i.e.  <a href="#a2ddf4816d6adf12474058fd944b210d2">More...</a><br /></td></tr>
<tr class="separator:a2ddf4816d6adf12474058fd944b210d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7250062b82d11b48902efa2d5522b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#aa7250062b82d11b48902efa2d5522b5e">mat_mul</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> M[2][2], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> V[], int i, int j)</td></tr>
<tr class="memdesc:aa7250062b82d11b48902efa2d5522b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x2 complex matrix multiplication  <a href="#aa7250062b82d11b48902efa2d5522b5e">More...</a><br /></td></tr>
<tr class="separator:aa7250062b82d11b48902efa2d5522b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9592cc8adee5a123e160ef48e519c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#afb9592cc8adee5a123e160ef48e519c8">mat_mul_4</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> M[4][4], <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> V[], int i, int j, int k, int l)</td></tr>
<tr class="memdesc:afb9592cc8adee5a123e160ef48e519c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 matrix  <a href="#afb9592cc8adee5a123e160ef48e519c8">More...</a><br /></td></tr>
<tr class="separator:afb9592cc8adee5a123e160ef48e519c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f85ec981f7f9d5658ac1a2b3abcbdd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a1f85ec981f7f9d5658ac1a2b3abcbdd9">qubit_display</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int N)</td></tr>
<tr class="memdesc:a1f85ec981f7f9d5658ac1a2b3abcbdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the state amplitudes on LEDs.  <a href="#a1f85ec981f7f9d5658ac1a2b3abcbdd9">More...</a><br /></td></tr>
<tr class="separator:a1f85ec981f7f9d5658ac1a2b3abcbdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ddb54528109f39f37fa2949c3a6d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#aa22ddb54528109f39f37fa2949c3a6d9">single_qubit_op</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> op[2][2], int k, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int N)</td></tr>
<tr class="memdesc:aa22ddb54528109f39f37fa2949c3a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply operator  <a href="#aa22ddb54528109f39f37fa2949c3a6d9">More...</a><br /></td></tr>
<tr class="separator:aa22ddb54528109f39f37fa2949c3a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dbd3f2bfb00d98ef4e278b2b578b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a65dbd3f2bfb00d98ef4e278b2b578b5f">controlled_qubit_op</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> op[2][2], int ctrl, int targ, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int N)</td></tr>
<tr class="memdesc:a65dbd3f2bfb00d98ef4e278b2b578b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">selective 2 qubit op function 00 01 10 11 00( 1 0 0 0 ) 01( 0 1 0 0 ) 10( 0 0 u00 u01 ) 11( 0 0 u10 u11 ) checks that the control qubit is |1&gt; then does 2x2 unitary on remaining state vector  <a href="#a65dbd3f2bfb00d98ef4e278b2b578b5f">More...</a><br /></td></tr>
<tr class="separator:a65dbd3f2bfb00d98ef4e278b2b578b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94844d5460515e4cbc5d3c2ef49ca680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a94844d5460515e4cbc5d3c2ef49ca680">sort_states</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int num_qubits)</td></tr>
<tr class="separator:a94844d5460515e4cbc5d3c2ef49ca680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af863f8a077581846bfff362facd094"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="quantum_8c.html#a9af863f8a077581846bfff362facd094">remove_zero_amp_states</a> (<a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> state[], int num_qubits, <a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a> disp_state[])</td></tr>
<tr class="memdesc:a9af863f8a077581846bfff362facd094"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes state vector, number of qubits and vector to write the nonzero elements of the statevector to.  <a href="#a9af863f8a077581846bfff362facd094">More...</a><br /></td></tr>
<tr class="separator:a9af863f8a077581846bfff362facd094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Description: Contains matrix and vector arithmetic for simulating one qubit. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a43ed06e2eeade77b541d88b3fe875a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ed06e2eeade77b541d88b3fe875a05">&#9670;&nbsp;</a></span>NUM_MAX_AMPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_MAX_AMPS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state vector </td></tr>
    <tr><td class="paramname">num_qubits</td><td>The number of qubits in the state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>This function finds the amplitude of the state vector with the largest magnitude. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4c505ea21f44c1e8e4f15b71b19b8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c505ea21f44c1e8e4f15b71b19b8cf3">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="quantum_8h.html#a66dbef8ee970f4d9747e8bb5533d2a92">Q15</a> absolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A complex number to find the absolute value of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Check that the complex part is small </dd></dl>

</div>
</div>
<a id="a65dbd3f2bfb00d98ef4e278b2b578b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dbd3f2bfb00d98ef4e278b2b578b5f">&#9670;&nbsp;</a></span>controlled_qubit_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void controlled_qubit_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>op</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>selective 2 qubit op function 00 01 10 11 00( 1 0 0 0 ) 01( 0 1 0 0 ) 10( 0 0 u00 u01 ) 11( 0 0 u10 u11 ) checks that the control qubit is |1&gt; then does 2x2 unitary on remaining state vector </p>
<p>apply controlled 2x2 op </p>
<p>ROOT loop: starts at 0, increases in steps of 1</p>
<p>STEP loop: starts at 0, increases in steps of 2^(k+1)</p>
<p>First index is ZERO, second index is ONE </p><dl class="section note"><dt>Note</dt><dd>for 2 qubit case check if the index in the ctrl qubit is a 1 then apply the 2x2 unitary else do nothing</dd>
<dd>
sorry. this checks for the first element of the state vector i.e. the target qubits |0&gt; and checks that the state vector element is one which the control qubit has a |1&gt; state -&gt; (root + step)</dd></dl>
<p>The second element of the state vector to take is then the first +2^(target qubit number). This also needs to be checked that the control qubit is in the |1&gt;. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>This expression can probably be simplified or broken over lines. </dd></dl>

</div>
</div>
<a id="a7978688debb14063b164d6f6b279d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7978688debb14063b164d6f6b279d839">&#9670;&nbsp;</a></span>make_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>X</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>Y</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>Z</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>H</em>[2][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create complex X, Y, Z and H. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Pauli X c-Matrix </td></tr>
    <tr><td class="paramname">Z</td><td>Pauli Z c-matrix </td></tr>
    <tr><td class="paramname">H</td><td>Hadamard c-matrix </td></tr>
    <tr><td class="paramname">Y</td><td>Pauli Y c-matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>IMPLICIT NONE!!! </dd></dl>

</div>
</div>
<a id="aa51694e4352698790c3ae8337e72a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51694e4352698790c3ae8337e72a439">&#9670;&nbsp;</a></span>make_ops_4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_ops_4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>CNOT</em>[4][4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>CPHASE</em>[4][4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>SWAP</em>[4][4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[][] = row, col </p>

</div>
</div>
<a id="aa7250062b82d11b48902efa2d5522b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7250062b82d11b48902efa2d5522b5e">&#9670;&nbsp;</a></span>mat_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mat_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>M</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>V</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2x2 complex matrix multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>complex matrix </td></tr>
    <tr><td class="paramname">V</td><td>complex vector </td></tr>
    <tr><td class="paramname">i</td><td>integer first element of state vector </td></tr>
    <tr><td class="paramname">j</td><td>integer second element of state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Because of the way the array types work (you can't pass a multidimensional array of unknown size) we will also need a function for 4x4 matrix multiplication. </dd></dl>

</div>
</div>
<a id="afb9592cc8adee5a123e160ef48e519c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9592cc8adee5a123e160ef48e519c8">&#9670;&nbsp;</a></span>mat_mul_4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mat_mul_4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>M</em>[4][4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>V</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>4x4 matrix </p>
<p>4x4 complex matrix multiplication </p>
<p>store results of each row multiplication</p>
<p>4 cols of V (i,h,k,l)</p>
<p>add the 4 terms together and put into temp for that row </p>

</div>
</div>
<a id="a1f85ec981f7f9d5658ac1a2b3abcbdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f85ec981f7f9d5658ac1a2b3abcbdd9">&#9670;&nbsp;</a></span>qubit_display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qubit_display </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the state amplitudes on LEDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pass in the state vector </td></tr>
    <tr><td class="paramname">N</td><td>The total number of qubits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently the function only displays superpositions using the red and blue colors.</dd></dl>
<p>The routine works by adding up the squares of the amplitudes corresponding to each state of a given qubit. Suppose there are three qubits. Then the state vector is given by </p><h2>index binary amplitude </h2>
<p>0 0 0 0 a0 1 0 0 1 a1 2 0 1 0 a2 3 0 1 1 a3 4 1 0 0 a4 5 1 0 1 a5 6 1 1 0 a6 </p><h2>7 1 1 1 a7 </h2>
<p>Qubit: 2 1 0</p>
<p>Consider qubit 2. The value of the ZERO state is formed by adding up all the amplitudes corresponding to its ZERO state. That is, indices 0, 1, 2 and 3. The ONE state is obtained by adding up the other indices: 4, 5, 6 and</p><ol type="1">
<li></li>
</ol>
<p>So the amplitudes for qubit 2 are</p>
<p>ZERO: (a_0)^2 + (a_1)^2 + (a_2)^2 + (a_3)^2 ONE: (a_4)^2 + (a_5)^2 + (a_6)^2 + (a_7)^2</p>
<p>Corresponding to the following indices:</p>
<p>ZERO: 0+0, 1+0, 2+0, 3+0 ONE: 4+0, 5+0, 6+0, 7+0</p>
<p>For qubit 1 the indices are:</p>
<p>ZERO: 0+0, 0+4, 1+0, 1+4 ONE: 2+0, 2+4, 3+0, 3+4</p>
<p>And for qubit 0 the indices are:</p>
<p>ZERO: 0+0, 0+2, 0+4, 0+6 ONE: 1+0, 1+2, 1+4, 1+6</p>
<p>The examples above are supposed to show the general pattern. For N qubits, qubit number k, the ZERO and ONE states are given by summing all the square amplitudes corresponding to the following indices:</p>
<p>ZERO: n + (2^(k+1) * j), where n = 0, 1, ..., 2^k - 1 and j = 0, 1, ..., 2^(N-k-2)</p>
<p>ONE: n + (2^(k+1) * j), where n = 2^k, 2^k + 1, ..., 2^(k+1) - 1 and j = 0, 1, ..., 2^(N-k-2)</p>
<p>The amplitudes are obtained by summing over both n and j. Notice that there is an edge condition when k = N-1. There, j apparently ranges from 0 to -1. In this case, the only value of j is 0. The condition arises because of the way that 2^(N-k-2) is obtained (i.e. such that multiplying it by 2^(k+1) gives 2^(N-1).) However, if k = N-1, then 2^(k+1) = 2^N already, so it must be multiplied by 2^(-1). The key point is that the second term should not ever equal 2^N, so j should stop at 0.</p>
<p>The above indices can be expressed as the sum of a ROOT and a STEP as follows:</p>
<p>index = ROOT + STEP</p>
<p>where ROOT ranges from 0 to 2^k-1. This corresponds to the n values that give rise to ZERO. The indices for ONE can be obtained by adding 2^k to root. The STEP = j is a multiple of 2^(k+1) starting from zero that does not equal or exceed 2^N. ROOT can be realised using the following for loop:</p>
<p>for(int root = 0; root &lt; 2^k; root ++) { ... // ZERO index root; // ONE index root + 2^k; }</p>
<p>Then the STEP component can be realised as</p>
<p>for(int step = 0; step &lt; 2^N; step += 2^(k+1)) { // Add the following to root... step; } </p>
<p>Loop over all qubits k = 0, 1, 2, ... N-1</p>
<p>ROOT loop: starts at 0, increases in steps of 1</p>
<p>STEP loop: starts at 0, increases in steps of 2^(k+1)</p>
<p>Zeros are at the index root + step</p>
<p>Ones are at the index root + 2^k + step</p>
<p>update leds for each qubits average zero and one amps </p>

</div>
</div>
<a id="a9af863f8a077581846bfff362facd094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af863f8a077581846bfff362facd094">&#9670;&nbsp;</a></span>remove_zero_amp_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int remove_zero_amp_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>disp_state</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>takes state vector, number of qubits and vector to write the nonzero elements of the statevector to. </p>
<p>updates disp_state where the first 'return value of the function'elements are the nonzero elements of the state vector 'state'</p>
<p>the disp_state elements are the nonzero elements of the state e.g. state = (00) = (1/r2) (Bell state) (01) ( 0 ) (10) ( 0 ) (11) (1/r2) Then displ_state would have 2 elements disp_state = (0) standing for (00) (3) (11) </p><dl class="section note"><dt>Note</dt><dd>we have to allocate disp_state to be the size of state, the function returns count which tells us the first 'count' elements of disp_state to use. In the Bell state example there are 2 values in disp_state, 0 &amp; 3, count is returned as 3 which means take the first count-1 elements (in this case 2) of disp_state which is 0,1 which is the correct elements </dd></dl>

</div>
</div>
<a id="aa22ddb54528109f39f37fa2949c3a6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22ddb54528109f39f37fa2949c3a6d9">&#9670;&nbsp;</a></span>single_qubit_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void single_qubit_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>op</em>[2][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>state vector containing amplitudes </td></tr>
    <tr><td class="paramname">qubit</td><td>qubit number to apply 2x2 matrix to </td></tr>
    <tr><td class="paramname">N</td><td>total number of qubits in the state </td></tr>
    <tr><td class="paramname">op</td><td>2x2 operator to be applied</td></tr>
  </table>
  </dd>
</dl>
<p>This routine applies a single qubit gate to the state vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state.</td><td>Consider the three qubit case, with amplitudes shown in the table below: <h2>index binary amplitude </h2>
</td></tr>
  </table>
  </dd>
</dl>
<p>0 0 0 0 a0 1 0 0 1 a1 2 0 1 0 a2 3 0 1 1 a3 4 1 0 0 a4 5 1 0 1 a5 6 1 1 0 a6 </p><h2>7 1 1 1 a7 </h2>
<p>Qubit: 2 1 0</p>
<p>If a single qubit operation is applied to qubit 2, then the 2x2 matrix must be applied to all pairs of (0,1) in the first column, with the numbers in the other columns fixed. In other words, the following indices are paired: </p><pre class="fragment">  (0+0) (1+0) (2+0) (3+0)
  (4+0) (5+0) (6+0) (7+0)
</pre><p>where the top line corresponds to the ZERO amplitude and the bottom row corresponds to the ONE amplitude.</p>
<p>Similarly, for qubit 1 the pairings are: </p><pre class="fragment">  (0+0) (0+4) (1+0) (1+4)
  (2+0) (2+4) (3+0) (3+4)
</pre><p>And for qubit 0 the pairings are: </p><pre class="fragment">  (0+0) (0+2) (0+4) (0+6)
  (1+0) (1+2) (1+4) (1+6)
</pre><p>These numbers are exactly the same as the previous function, which means the same nested loops can be used to perform operation. Now the index </p><pre class="fragment"> root + step 
</pre><p>refers to the ZERO amplitude (the first element in the column vector to be multiplied by the 2x2 matrix), and the index </p><pre class="fragment"> root + 2^k + step
</pre><p>corresponds to the ONE entry. </p>
<p>ROOT loop: starts at 0, increases in steps of 1</p>
<p>STEP loop: starts at 0, increases in steps of 2^(k+1)</p>
<p>First index is ZERO, second index is ONE </p>

</div>
</div>
<a id="a94844d5460515e4cbc5d3c2ef49ca680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94844d5460515e4cbc5d3c2ef49ca680">&#9670;&nbsp;</a></span>sort_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sort_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_qubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Array for largest amplitudes</p>
<p>To store the position of the amplitudes</p>
<p>/ Sort the state. Look through every element storing it if it is larger / and than the previous largest element for(int j=0; j&lt;N; j++){ </p><pre class="fragment">     Sort the state. 

     max is always in ascending order. Elemen
</pre><p>int k = NUM_MAX_AMPS - 1; for(int j=0; j&lt;N; j++){ / Compute the magnitude of the element if(absolute(state[j]) &gt;= max[k]) { max[k] = absolute(state[j]); k++; /// Increment k to point to next position in max } }</p>
<pre class="fragment">    if(max_amp[count] &lt;= state[j][0]){
        count++;
</pre><p> update new maximum val max_amp[count] = state[j][0]; save pos of maximal val amp_index[count] = j; }</p>
<p>} / now have arrays of out_state and amplitudes of size count / need to decode int of the out_state to binary to find each quits state </p><pre class="fragment">while(1){
</pre><p> loop over all max vals of the state for(int l=1; l&lt;=count; l++){ / display the states of three qubits for(int k=0; k&lt;4; k++){ / I know this is wrong it returns one_amp as 0x0002 / which means zero_amp becomes 0xFFFF because of overflow?</p>
<p>/ </p><dl class="section note"><dt>Note</dt><dd>Changed to unsigned Fract to match set_external_led args in <a class="el" href="io_8c.html" title="Contains all the functions for reading buttons and writing to LEDs. ">io.c</a> unsigned _Fract one_amp=(amp_index[l] &amp; (1 &lt;&lt; k)); unsigned _Fract zero_amp=1-one_amp; set_external_led(k, 0,zero_amp, one_amp);</dd></dl>
<p>}</p>
<p>let the user see /</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>wait for John to fix the timer so the microprocessor isn't locked out while displaying state counter1 = 0; while(counter1 &lt;= 1000000){ counter1++; } } }</dd></dl>
<pre class="fragment"></pre>
</div>
</div>
<a id="a2ddf4816d6adf12474058fd944b210d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddf4816d6adf12474058fd944b210d2">&#9670;&nbsp;</a></span>zero_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zero_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="quantum_8h.html#ab32a0935b29bf7784d29e5669c59e588">Complex</a>&#160;</td>
          <td class="paramname"><em>state</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Qnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise state to the vacuum (zero apart from the first position) Specify the dimension &ndash; of the matrix, i.e. </p>
<p>2^(number of qubits) </p>
<dl class="section note"><dt>Note</dt><dd>oh the clarity! </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
